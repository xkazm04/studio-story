/**
 * SmartGrouper - Intelligent asset organization and grouping system
 *
 * Automatically groups assets based on metadata, tags, type, and content
 * similarity. Supports curated collections and folder hierarchies.
 */

import type { Asset } from '@/app/types/Asset';

export type GroupingStrategy =
  | 'type'
  | 'subcategory'
  | 'tags'
  | 'date'
  | 'compatibility'
  | 'smart';

export interface SmartGroup {
  id: string;
  name: string;
  description?: string;
  strategy: GroupingStrategy;
  assetIds: string[];
  assetCount: number;
  icon?: string;
  color?: string;
  createdAt: number;
  isAutoGenerated: boolean;
}

export interface Collection {
  id: string;
  name: string;
  description?: string;
  icon?: string;
  color?: string;
  assetIds: string[];
  parentId?: string;
  order: number;
  isTemplate?: boolean;
  sharedWithProjects?: string[];
  createdAt: number;
  updatedAt: number;
}

export interface Folder {
  id: string;
  name: string;
  parentId?: string;
  order: number;
  color?: string;
  isExpanded?: boolean;
  children: string[];
  collectionIds: string[];
  createdAt: number;
}

export interface CollectionTemplate {
  id: string;
  name: string;
  description: string;
  defaultAssetTypes: string[];
  defaultTags: string[];
  icon: string;
  color: string;
}

const STORAGE_KEY_COLLECTIONS = 'story-asset-collections';
const STORAGE_KEY_FOLDERS = 'story-asset-folders';

// Default collection templates
const defaultTemplates: CollectionTemplate[] = [
  {
    id: 'character-essentials',
    name: 'Character Essentials',
    description: 'Core assets for character creation',
    defaultAssetTypes: ['Body', 'Clothing', 'Accessories'],
    defaultTags: ['character', 'avatar'],
    icon: 'users',
    color: 'cyan',
  },
  {
    id: 'scene-backgrounds',
    name: 'Scene Backgrounds',
    description: 'Backgrounds and locations for scenes',
    defaultAssetTypes: ['Background', 'Location', 'Scene'],
    defaultTags: ['background', 'environment'],
    icon: 'image',
    color: 'purple',
  },
  {
    id: 'props-equipment',
    name: 'Props & Equipment',
    description: 'Items and equipment for characters',
    defaultAssetTypes: ['Props', 'Equipment'],
    defaultTags: ['prop', 'item', 'weapon'],
    icon: 'box',
    color: 'amber',
  },
  {
    id: 'favorites',
    name: 'Favorites',
    description: 'Your favorite assets',
    defaultAssetTypes: [],
    defaultTags: [],
    icon: 'star',
    color: 'yellow',
  },
];

class SmartGrouperImpl {
  private collections: Map<string, Collection> = new Map();
  private folders: Map<string, Folder> = new Map();
  private listeners: Set<() => void> = new Set();

  constructor() {
    this.loadFromStorage();
  }

  private loadFromStorage(): void {
    if (typeof window === 'undefined') return;

    try {
      const savedCollections = localStorage.getItem(STORAGE_KEY_COLLECTIONS);
      if (savedCollections) {
        const parsed = JSON.parse(savedCollections);
        this.collections = new Map(Object.entries(parsed));
      }

      const savedFolders = localStorage.getItem(STORAGE_KEY_FOLDERS);
      if (savedFolders) {
        const parsed = JSON.parse(savedFolders);
        this.folders = new Map(Object.entries(parsed));
      }
    } catch (error) {
      console.warn('Failed to load collections:', error);
    }
  }

  private saveToStorage(): void {
    if (typeof window === 'undefined') return;

    try {
      const collectionsObj = Object.fromEntries(this.collections);
      localStorage.setItem(STORAGE_KEY_COLLECTIONS, JSON.stringify(collectionsObj));

      const foldersObj = Object.fromEntries(this.folders);
      localStorage.setItem(STORAGE_KEY_FOLDERS, JSON.stringify(foldersObj));
    } catch (error) {
      console.warn('Failed to save collections:', error);
    }
  }

  private notify(): void {
    this.listeners.forEach(listener => listener());
  }

  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  // ============ Smart Grouping ============

  /**
   * Generate smart groups from assets based on a strategy
   */
  generateSmartGroups(assets: Asset[], strategy: GroupingStrategy): SmartGroup[] {
    switch (strategy) {
      case 'type':
        return this.groupByType(assets);
      case 'subcategory':
        return this.groupBySubcategory(assets);
      case 'tags':
        return this.groupByTags(assets);
      case 'date':
        return this.groupByDate(assets);
      case 'compatibility':
        return this.groupByCompatibility(assets);
      case 'smart':
        return this.generateSmartGrouping(assets);
      default:
        return this.groupByType(assets);
    }
  }

  private groupByType(assets: Asset[]): SmartGroup[] {
    const groups: Map<string, string[]> = new Map();

    assets.forEach(asset => {
      const type = asset.type || 'Unknown';
      const existing = groups.get(type) || [];
      groups.set(type, [...existing, asset._id]);
    });

    return Array.from(groups.entries()).map(([type, assetIds]) => ({
      id: `type-${type.toLowerCase()}`,
      name: type,
      strategy: 'type' as GroupingStrategy,
      assetIds,
      assetCount: assetIds.length,
      isAutoGenerated: true,
      createdAt: Date.now(),
    }));
  }

  private groupBySubcategory(assets: Asset[]): SmartGroup[] {
    const groups: Map<string, string[]> = new Map();

    assets.forEach(asset => {
      const subcategory = asset.subcategory || 'Uncategorized';
      const existing = groups.get(subcategory) || [];
      groups.set(subcategory, [...existing, asset._id]);
    });

    return Array.from(groups.entries()).map(([subcategory, assetIds]) => ({
      id: `subcat-${subcategory.toLowerCase().replace(/\s+/g, '-')}`,
      name: subcategory,
      strategy: 'subcategory' as GroupingStrategy,
      assetIds,
      assetCount: assetIds.length,
      isAutoGenerated: true,
      createdAt: Date.now(),
    }));
  }

  private groupByTags(assets: Asset[]): SmartGroup[] {
    const groups: Map<string, string[]> = new Map();

    assets.forEach(asset => {
      const tags = asset.metadata?.tags || [];
      if (tags.length === 0) {
        const existing = groups.get('Untagged') || [];
        groups.set('Untagged', [...existing, asset._id]);
      } else {
        tags.forEach(tag => {
          const existing = groups.get(tag) || [];
          groups.set(tag, [...existing, asset._id]);
        });
      }
    });

    return Array.from(groups.entries())
      .sort((a, b) => b[1].length - a[1].length)
      .slice(0, 20) // Top 20 tags
      .map(([tag, assetIds]) => ({
        id: `tag-${tag.toLowerCase().replace(/\s+/g, '-')}`,
        name: tag,
        strategy: 'tags' as GroupingStrategy,
        assetIds,
        assetCount: assetIds.length,
        isAutoGenerated: true,
        createdAt: Date.now(),
      }));
  }

  private groupByDate(assets: Asset[]): SmartGroup[] {
    const now = Date.now();
    const day = 24 * 60 * 60 * 1000;

    const groups: Record<string, string[]> = {
      'Today': [],
      'This Week': [],
      'This Month': [],
      'Older': [],
    };

    assets.forEach(asset => {
      if (!asset.created_at) {
        groups['Older'].push(asset._id);
        return;
      }

      const created = new Date(asset.created_at).getTime();
      const diff = now - created;

      if (diff < day) {
        groups['Today'].push(asset._id);
      } else if (diff < 7 * day) {
        groups['This Week'].push(asset._id);
      } else if (diff < 30 * day) {
        groups['This Month'].push(asset._id);
      } else {
        groups['Older'].push(asset._id);
      }
    });

    return Object.entries(groups)
      .filter(([, assetIds]) => assetIds.length > 0)
      .map(([name, assetIds]) => ({
        id: `date-${name.toLowerCase().replace(/\s+/g, '-')}`,
        name,
        strategy: 'date' as GroupingStrategy,
        assetIds,
        assetCount: assetIds.length,
        isAutoGenerated: true,
        createdAt: Date.now(),
      }));
  }

  private groupByCompatibility(assets: Asset[]): SmartGroup[] {
    const groups: Map<string, string[]> = new Map();

    assets.forEach(asset => {
      const compatibleWith = asset.metadata?.compatible_with || [];
      if (compatibleWith.length === 0) {
        const existing = groups.get('Universal') || [];
        groups.set('Universal', [...existing, asset._id]);
      } else {
        compatibleWith.forEach(compat => {
          const existing = groups.get(compat) || [];
          groups.set(compat, [...existing, asset._id]);
        });
      }
    });

    return Array.from(groups.entries()).map(([compatibility, assetIds]) => ({
      id: `compat-${compatibility.toLowerCase().replace(/\s+/g, '-')}`,
      name: `Compatible with ${compatibility}`,
      strategy: 'compatibility' as GroupingStrategy,
      assetIds,
      assetCount: assetIds.length,
      isAutoGenerated: true,
      createdAt: Date.now(),
    }));
  }

  /**
   * Generate intelligent grouping based on multiple factors
   */
  private generateSmartGrouping(assets: Asset[]): SmartGroup[] {
    const groups: SmartGroup[] = [];

    // Group by primary type with subcategory
    const typeSubcatGroups: Map<string, string[]> = new Map();
    assets.forEach(asset => {
      const key = asset.subcategory
        ? `${asset.type} - ${asset.subcategory}`
        : asset.type || 'Unknown';
      const existing = typeSubcatGroups.get(key) || [];
      typeSubcatGroups.set(key, [...existing, asset._id]);
    });

    typeSubcatGroups.forEach((assetIds, name) => {
      groups.push({
        id: `smart-${name.toLowerCase().replace(/[\s-]+/g, '-')}`,
        name,
        strategy: 'smart',
        assetIds,
        assetCount: assetIds.length,
        isAutoGenerated: true,
        createdAt: Date.now(),
      });
    });

    // Add special groups based on common tags
    const tagCounts: Map<string, number> = new Map();
    assets.forEach(asset => {
      (asset.metadata?.tags || []).forEach(tag => {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
    });

    // Create groups for popular tags (>= 3 assets)
    tagCounts.forEach((count, tag) => {
      if (count >= 3) {
        const assetIds = assets
          .filter(a => a.metadata?.tags?.includes(tag))
          .map(a => a._id);

        groups.push({
          id: `smart-tag-${tag.toLowerCase().replace(/\s+/g, '-')}`,
          name: `Tagged: ${tag}`,
          strategy: 'smart',
          assetIds,
          assetCount: assetIds.length,
          isAutoGenerated: true,
          createdAt: Date.now(),
        });
      }
    });

    return groups.sort((a, b) => b.assetCount - a.assetCount);
  }

  // ============ Collection Management ============

  /**
   * Create a new collection
   */
  createCollection(
    name: string,
    options?: {
      description?: string;
      icon?: string;
      color?: string;
      parentId?: string;
      assetIds?: string[];
      isTemplate?: boolean;
    }
  ): Collection {
    const collection: Collection = {
      id: this.generateId(),
      name,
      description: options?.description,
      icon: options?.icon,
      color: options?.color,
      assetIds: options?.assetIds || [],
      parentId: options?.parentId,
      order: this.collections.size,
      isTemplate: options?.isTemplate,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };

    this.collections.set(collection.id, collection);
    this.saveToStorage();
    this.notify();

    return collection;
  }

  /**
   * Create collection from template
   */
  createFromTemplate(
    templateId: string,
    assets: Asset[],
    customName?: string
  ): Collection | null {
    const template = defaultTemplates.find(t => t.id === templateId);
    if (!template) return null;

    // Filter assets matching template criteria
    const matchingAssetIds = assets
      .filter(asset => {
        const typeMatch =
          template.defaultAssetTypes.length === 0 ||
          template.defaultAssetTypes.includes(asset.type);
        const tagMatch =
          template.defaultTags.length === 0 ||
          template.defaultTags.some(tag =>
            asset.metadata?.tags?.includes(tag)
          );
        return typeMatch || tagMatch;
      })
      .map(a => a._id);

    return this.createCollection(customName || template.name, {
      description: template.description,
      icon: template.icon,
      color: template.color,
      assetIds: matchingAssetIds,
    });
  }

  /**
   * Update a collection
   */
  updateCollection(
    collectionId: string,
    updates: Partial<Omit<Collection, 'id' | 'createdAt'>>
  ): Collection | null {
    const collection = this.collections.get(collectionId);
    if (!collection) return null;

    const updated: Collection = {
      ...collection,
      ...updates,
      updatedAt: Date.now(),
    };

    this.collections.set(collectionId, updated);
    this.saveToStorage();
    this.notify();

    return updated;
  }

  /**
   * Delete a collection
   */
  deleteCollection(collectionId: string): boolean {
    if (!this.collections.has(collectionId)) return false;

    this.collections.delete(collectionId);

    // Remove from parent folder if any
    this.folders.forEach(folder => {
      if (folder.collectionIds.includes(collectionId)) {
        folder.collectionIds = folder.collectionIds.filter(id => id !== collectionId);
      }
    });

    this.saveToStorage();
    this.notify();
    return true;
  }

  /**
   * Add assets to a collection
   */
  addToCollection(collectionId: string, assetIds: string[]): boolean {
    const collection = this.collections.get(collectionId);
    if (!collection) return false;

    const newAssetIds = assetIds.filter(id => !collection.assetIds.includes(id));
    if (newAssetIds.length === 0) return true;

    collection.assetIds = [...collection.assetIds, ...newAssetIds];
    collection.updatedAt = Date.now();

    this.saveToStorage();
    this.notify();
    return true;
  }

  /**
   * Remove assets from a collection
   */
  removeFromCollection(collectionId: string, assetIds: string[]): boolean {
    const collection = this.collections.get(collectionId);
    if (!collection) return false;

    collection.assetIds = collection.assetIds.filter(id => !assetIds.includes(id));
    collection.updatedAt = Date.now();

    this.saveToStorage();
    this.notify();
    return true;
  }

  /**
   * Get a collection by ID
   */
  getCollection(collectionId: string): Collection | undefined {
    return this.collections.get(collectionId);
  }

  /**
   * Get all collections
   */
  getAllCollections(): Collection[] {
    return Array.from(this.collections.values()).sort((a, b) => a.order - b.order);
  }

  /**
   * Get available templates
   */
  getTemplates(): CollectionTemplate[] {
    return defaultTemplates;
  }

  // ============ Folder Management ============

  /**
   * Create a new folder
   */
  createFolder(
    name: string,
    options?: { parentId?: string; color?: string }
  ): Folder {
    const folder: Folder = {
      id: this.generateId(),
      name,
      parentId: options?.parentId,
      order: this.folders.size,
      color: options?.color,
      isExpanded: true,
      children: [],
      collectionIds: [],
      createdAt: Date.now(),
    };

    this.folders.set(folder.id, folder);

    // Add to parent's children
    if (options?.parentId) {
      const parent = this.folders.get(options.parentId);
      if (parent) {
        parent.children.push(folder.id);
      }
    }

    this.saveToStorage();
    this.notify();

    return folder;
  }

  /**
   * Update a folder
   */
  updateFolder(
    folderId: string,
    updates: Partial<Omit<Folder, 'id' | 'createdAt'>>
  ): Folder | null {
    const folder = this.folders.get(folderId);
    if (!folder) return null;

    const updated: Folder = { ...folder, ...updates };
    this.folders.set(folderId, updated);
    this.saveToStorage();
    this.notify();

    return updated;
  }

  /**
   * Delete a folder and optionally its contents
   */
  deleteFolder(folderId: string, deleteContents = false): boolean {
    const folder = this.folders.get(folderId);
    if (!folder) return false;

    // Handle children
    if (deleteContents) {
      folder.children.forEach(childId => this.deleteFolder(childId, true));
      folder.collectionIds.forEach(collId => this.deleteCollection(collId));
    } else {
      // Move children to parent or root
      folder.children.forEach(childId => {
        const child = this.folders.get(childId);
        if (child) {
          child.parentId = folder.parentId;
        }
      });

      // Move collections to parent or root
      if (folder.parentId) {
        const parent = this.folders.get(folder.parentId);
        if (parent) {
          parent.collectionIds = [...parent.collectionIds, ...folder.collectionIds];
        }
      }
    }

    // Remove from parent's children
    if (folder.parentId) {
      const parent = this.folders.get(folder.parentId);
      if (parent) {
        parent.children = parent.children.filter(id => id !== folderId);
      }
    }

    this.folders.delete(folderId);
    this.saveToStorage();
    this.notify();
    return true;
  }

  /**
   * Add collection to folder
   */
  addCollectionToFolder(folderId: string, collectionId: string): boolean {
    const folder = this.folders.get(folderId);
    const collection = this.collections.get(collectionId);
    if (!folder || !collection) return false;

    // Remove from current parent folder if any
    this.folders.forEach(f => {
      if (f.collectionIds.includes(collectionId)) {
        f.collectionIds = f.collectionIds.filter(id => id !== collectionId);
      }
    });

    folder.collectionIds.push(collectionId);
    collection.parentId = folderId;
    collection.updatedAt = Date.now();

    this.saveToStorage();
    this.notify();
    return true;
  }

  /**
   * Get a folder by ID
   */
  getFolder(folderId: string): Folder | undefined {
    return this.folders.get(folderId);
  }

  /**
   * Get all root-level folders
   */
  getRootFolders(): Folder[] {
    return Array.from(this.folders.values())
      .filter(f => !f.parentId)
      .sort((a, b) => a.order - b.order);
  }

  /**
   * Get folder tree structure
   */
  getFolderTree(): Array<Folder & { childFolders: Folder[]; collections: Collection[] }> {
    const buildTree = (parentId?: string): Array<Folder & { childFolders: Folder[]; collections: Collection[] }> => {
      return Array.from(this.folders.values())
        .filter(f => f.parentId === parentId)
        .sort((a, b) => a.order - b.order)
        .map(folder => ({
          ...folder,
          childFolders: buildTree(folder.id) as unknown as Folder[],
          collections: folder.collectionIds
            .map(id => this.collections.get(id))
            .filter((c): c is Collection => c !== undefined),
        }));
    };

    return buildTree(undefined);
  }

  /**
   * Toggle folder expanded state
   */
  toggleFolderExpanded(folderId: string): void {
    const folder = this.folders.get(folderId);
    if (folder) {
      folder.isExpanded = !folder.isExpanded;
      this.saveToStorage();
      this.notify();
    }
  }

  // ============ Sharing ============

  /**
   * Share collection with projects
   */
  shareWithProjects(collectionId: string, projectIds: string[]): boolean {
    const collection = this.collections.get(collectionId);
    if (!collection) return false;

    collection.sharedWithProjects = [
      ...new Set([...(collection.sharedWithProjects || []), ...projectIds]),
    ];
    collection.updatedAt = Date.now();

    this.saveToStorage();
    this.notify();
    return true;
  }

  /**
   * Unshare collection from projects
   */
  unshareFromProjects(collectionId: string, projectIds: string[]): boolean {
    const collection = this.collections.get(collectionId);
    if (!collection) return false;

    collection.sharedWithProjects = (collection.sharedWithProjects || []).filter(
      id => !projectIds.includes(id)
    );
    collection.updatedAt = Date.now();

    this.saveToStorage();
    this.notify();
    return true;
  }

  /**
   * Get collections shared with a project
   */
  getSharedCollections(projectId: string): Collection[] {
    return Array.from(this.collections.values()).filter(c =>
      c.sharedWithProjects?.includes(projectId)
    );
  }

  // ============ Utilities ============

  /**
   * Subscribe to changes
   */
  subscribe(listener: () => void): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  /**
   * Clear all data
   */
  clearAll(): void {
    this.collections.clear();
    this.folders.clear();
    this.saveToStorage();
    this.notify();
  }

  /**
   * Get collection count
   */
  getCollectionCount(): number {
    return this.collections.size;
  }

  /**
   * Get folder count
   */
  getFolderCount(): number {
    return this.folders.size;
  }
}

// Singleton instance
export const SmartGrouper = new SmartGrouperImpl();

export type { SmartGrouperImpl };
